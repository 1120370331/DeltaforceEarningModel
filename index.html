<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="last-updated" content="2024-11-14">
    <title>åŸºäºä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•°çš„æˆ˜æœ¯ç­–ç•¥ç»æµå­¦è¯„ä¼°ç ”ç©¶</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', 'Arial', sans-serif;
            background: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.9;
            margin-bottom: 20px;
        }

        .formula {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
        }

        .content {
            padding: 30px;
        }

        .step {
            margin-bottom: 40px;
            padding: 25px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .step-title {
            font-size: 1.8em;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .kappa-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin: 30px 0;
        }

        .kappa-display {
            font-size: 2em;
            font-weight: bold;
            color: #e74c3c;
            padding: 15px 25px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 10px;
            min-width: 250px;
            text-align: center;
        }

        .kappa-input {
            font-size: 1.5em;
            padding: 10px 15px;
            border: 2px solid #3498db;
            border-radius: 8px;
            width: 150px;
            text-align: center;
        }

        .btn {
            padding: 12px 24px;
            font-size: 1.1em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
            padding: 4px 8px;
            font-size: 0.8em;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        /* ä¼˜åŒ–æ‚¬æµ®æç¤ºæ ·å¼ */
        th[title] {
            position: relative;
            cursor: help;
        }

        th[title]:hover::after {
            content: attr(title);
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            background: #2c3e50;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            white-space: pre-line;
            font-size: 12px;
            font-weight: normal;
            z-index: 1000;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            max-width: 300px;
            word-wrap: break-word;
            margin-top: 5px;
        }

        th[title]:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            top: 100%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-bottom-color: #2c3e50;
            z-index: 1001;
            margin-top: 0;
        }

        .scenario-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .scenario-card {
            padding: 20px;
            border: 2px solid #bdc3c7;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 250px;
            max-width: 350px;
        }

        .scenario-card:hover {
            border-color: #3498db;
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }

        .scenario-card.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }

        .scenario-title {
            font-size: 1.3em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .scenario-description {
            font-size: 0.9em;
            line-height: 1.4;
        }

        .rankings-container {
            margin-bottom: 20px;
        }

        .edit-data-btn {
            margin-bottom: 15px;
        }

        .data-editor {
            display: none;
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .data-editor.active {
            display: block;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            font-size: 0.9em;
        }

        .data-table th,
        .data-table td {
            border: 1px solid #bdc3c7;
            padding: 8px;
            text-align: center;
        }

        .data-table th {
            background: #34495e;
            color: white;
        }

        .data-table input {
            width: 100%;
            border: none;
            padding: 4px;
            text-align: center;
            background: transparent;
            font-size: 0.9em;
        }

        .data-table input:focus {
            background: white;
            outline: 2px solid #3498db;
        }

        .rankings-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .rankings-table th,
        .rankings-table td {
            border: 1px solid #bdc3c7;
            padding: 12px;
            text-align: center;
        }

        .rankings-table th {
            background: #34495e;
            color: white;
            cursor: pointer;
            user-select: none;
            font-size: 0.95em;
        }

        .rankings-table th:hover {
            background: #2c3e50;
        }

        .rank-s { background: #e74c3c; color: white; font-weight: bold; }
        .rank-a { background: #f39c12; color: white; font-weight: bold; }
        .rank-b { background: #27ae60; color: white; font-weight: bold; }
        .rank-c { background: #3498db; color: white; font-weight: bold; }
        .rank-d { background: #95a5a6; color: white; font-weight: bold; }

        .sort-indicator {
            margin-left: 5px;
            font-size: 0.8em;
        }

        .indicators-explanation {
            margin: 20px 0;
            padding: 15px;
            background: #ecf0f1;
            border-radius: 8px;
            font-size: 0.9em;
        }

        .indicator-item {
            margin: 8px 0;
            padding: 8px;
            background: white;
            border-radius: 5px;
        }

        .indicator-name {
            font-weight: bold;
            color: #2c3e50;
        }

        .indicator-formula {
            font-family: 'Courier New', monospace;
            color: #e74c3c;
            margin: 4px 0;
        }

        .indicator-desc {
            color: #7f8c8d;
            font-style: italic;
        }

        /* å›¾è¡¨ç›¸å…³æ ·å¼ */
        .chart-container {
            position: relative;
            height: 500px;
            margin: 30px 0;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .key-insights {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #2196f3;
        }

        .key-insights h3 {
            margin-top: 0;
            color: #1976d2;
            margin-bottom: 15px;
        }

        .key-insights ul {
            margin: 10px 0;
            padding-left: 20px;
        }

        .key-insights li {
            margin: 10px 0;
            line-height: 1.5;
        }

        .chart-data-table {
            margin: 30px 0;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .chart-data-table h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #2c3e50;
            text-align: center;
        }

        .chart-data-table table {
            width: 100%;
            border-collapse: collapse;
            margin: 0 auto;
            max-width: 800px;
        }

        .chart-data-table th,
        .chart-data-table td {
            border: 1px solid #bdc3c7;
            padding: 12px 8px;
            text-align: center;
        }

        .chart-data-table th {
            background: #34495e;
            color: white;
            font-weight: bold;
        }

        .chart-data-table .positive {
            background: #d5f4e6;
            color: #27ae60;
            font-weight: bold;
        }

        .chart-data-table .negative {
            background: #fadbd8;
            color: #e74c3c;
            font-weight: bold;
        }

        .chart-data-table .zero {
            background: #f8f9fa;
            color: #7f8c8d;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>åŸºäºä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•°çš„æˆ˜æœ¯ç­–ç•¥ç»æµå­¦è¯„ä¼°ç ”ç©¶</h1>
            <div class="subtitle">Delta Force Earning Model - æˆ˜æœ¯æ”¶ç›Šåˆ†æç³»ç»Ÿ</div>
            <div class="formula">
                RI* = Î”R<sub>adj</sub> / (C<sub>eff</sub> Ã— T) = (AR - AL) Ã— SR / [(C + ÎºT) Ã— T]
            </div>
        </header>

        <div class="content">
            <!-- Step 1: Kappa Adjustment -->
            <div class="step" id="step1">
                <h2 class="step-title">ç¬¬ä¸€æ­¥ï¼šè®¾ç½®æ—¶é—´æœºä¼šæˆæœ¬å‚æ•° Îº</h2>
                <p style="text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                    è¯·è®¾ç½®æ‚¨è®¤ä¸ºçš„æ—¶é—´æœºä¼šæˆæœ¬å•ä»· Îºï¼ˆåŸºå‡†è®¾å®šï¼šÎº = 1 ä¸‡å“ˆå¤«å¸/åˆ†é’Ÿï¼‰
                </p>
                <div class="kappa-container">
                    <button class="btn btn-secondary" onclick="adjustKappa(-0.1)">â† -0.1</button>
                    <div class="kappa-display">
                        Îº = <span id="kappaValue">1.0</span> ä¸‡/åˆ†é’Ÿ
                    </div>
                    <button class="btn btn-secondary" onclick="adjustKappa(0.1)">+0.1 â†’</button>
                    <input type="number" class="kappa-input" id="kappaInput" value="1.0" step="0.1" onchange="setKappa(this.value)">
                </div>
                <div class="indicators-explanation">
                    <div class="indicator-item">
                        <div class="indicator-name">æ—¶é—´æœºä¼šæˆæœ¬ (Time Cost)</div>
                        <div class="indicator-formula">TimeCost = Îº Ã— T</div>
                        <div class="indicator-desc">æ¯ä½¿ç”¨1åˆ†é’Ÿæ—¶é—´ï¼Œè‡³å°‘æ‰¿æ‹…Îºä¸‡å“ˆå¤«å¸çš„æœºä¼šæˆæœ¬</div>
                    </div>
                </div>
            </div>

            <!-- Step 2: Scenario Selection -->
            <div class="step" id="step2">
                <h2 class="step-title">ç¬¬äºŒæ­¥ï¼šé€‰æ‹©ç©å®¶èº«ä»½</h2>
                <p style="text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                    è¯·é€‰æ‹©æ‚¨çš„ç©å®¶èº«ä»½ï¼Œè¿™å°†å½±å“æ¨¡å‹å‚æ•°
                </p>
                <div class="scenario-options">
                    <div class="scenario-card" onclick="selectScenario('runner')">
                        <div class="scenario-title">ğŸƒ è·‘åˆ€é¼ é¼ </div>
                        <div class="scenario-description">
                            è·‘åˆ€å•å±€æ”¶ç›Šç‡ +30%<br>
                            è·‘åˆ€å±€æ’¤ç¦»ç‡ +0.1<br>
                            çŒ›æ”»å±€æ’¤ç¦»ç‡ -0.1
                        </div>
                    </div>
                    <div class="scenario-card selected" onclick="selectScenario('normal')">
                        <div class="scenario-title">ğŸ‘¤ æ™®é€šç©å®¶</div>
                        <div class="scenario-description">
                            ä¸€åˆ‡ä¸å˜<br>
                            æ ‡å‡†æ¸¸æˆä½“éªŒ
                        </div>
                    </div>
                    <div class="scenario-card" onclick="selectScenario('expert')">
                        <div class="scenario-title">ğŸ¯ æŠ€æœ¯é«˜æ‰‹</div>
                        <div class="scenario-description">
                            çŒ›æ”»å±€æ’¤ç¦»ç‡ +0.1<br>
                            çŒ›æ”»å±€æ”¶ç›Š +30%<br>
                            å¯¹å±€æ—¶é•¿ -20%
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Rankings Display -->
            <div class="step" id="step3">
                <h2 class="step-title">ç¬¬ä¸‰æ­¥ï¼šä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•°æ’å</h2>

                <div class="indicators-explanation">
                    <h4 style="margin-bottom: 10px;">ğŸ“Š æŒ‡æ ‡è¯´æ˜</h4>
                    <div class="indicator-item">
                        <div class="indicator-name">ä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•°(RI*)</div>
                        <div class="indicator-formula">RI* = Î”R<sub>adj</sub> / (C<sub>eff</sub> Ã— T)</div>
                        <div class="indicator-desc">æˆæœ¬-æ—¶é—´åŒé‡çº¦æŸä¸‹çš„ç»¼åˆç»æµæ•ˆç‡ (å•ä½ï¼š1/åˆ†é’Ÿ)</div>
                    </div>
                    <div class="indicator-item">
                        <div class="indicator-name">æ¯åˆ†é’ŸæœŸæœ›å‡€æ”¶ç›Š(Jâ‚)</div>
                        <div class="indicator-formula">Jâ‚ = Î”R<sub>adj</sub> / T</div>
                        <div class="indicator-desc">å¼ºè°ƒ"èµšé’±é€Ÿåº¦"ï¼Œä½“ç°å•å±€çˆ†å‘èƒ½åŠ›</div>
                    </div>
                    <div class="indicator-item">
                        <div class="indicator-name">æ¯å•ä½æˆæœ¬æœŸæœ›å‡€æ”¶ç›Š(Jâ‚‚)</div>
                        <div class="indicator-formula">Jâ‚‚ = Î”R<sub>adj</sub> / C<sub>eff</sub></div>
                        <div class="indicator-desc">å¼ºè°ƒ"èµ„æœ¬æ•ˆç‡"ï¼Œä½“ç°å¯¹é’±åŒ…å‹å¥½ç¨‹åº¦</div>
                    </div>
                </div>

                <div style="text-align: center; margin: 20px 0;">
                    <a href="#chart-section" onclick="scrollToChart(event)" style="display: inline-block; padding: 12px 24px; background: #3498db; color: white; text-decoration: none; border-radius: 8px; font-weight: bold; transition: all 0.3s ease;">
                        ğŸ“ˆ æŸ¥çœ‹æ”¶ç›Šæ›²çº¿å¯¹æ¯”å›¾
                    </a>
                </div>

                <div class="rankings-container">
                    <div class="edit-data-btn">
                        <button class="btn btn-primary" onclick="toggleDataEditor()">ç¼–è¾‘æ•°æ®</button>
                    </div>

                    <!-- Rankings Table -->
                    <table class="rankings-table" id="rankingsTable">
                        <thead>
                            <tr>
                                <th onclick="sortRankings('strategy')" title="ç‚¹å‡»æ’åº">ç­–ç•¥åç§° <span class="sort-indicator"></span></th>
                                <th onclick="sortRankings('ri_star')" title="ä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•° = (æ”¶ç›Š-æŸè€—)Ã—æ’¤ç¦»ç‡ / ((æˆæœ¬+ÎºÃ—æ—¶é—´)Ã—æ—¶é—´)&#10;æ•°å€¼è¶Šé«˜ï¼Œå•ä½æ—¶é—´å‡€æ”¶ç›Šæ•ˆç‡è¶Šä¼˜ç§€">ä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•°(RI*) <span class="sort-indicator"></span></th>
                                <th onclick="sortRankings('j1')" title="æ¯åˆ†é’ŸæœŸæœ›å‡€æ”¶ç›Š = ((æ”¶ç›Š-æŸè€—)Ã—æ’¤ç¦»ç‡ - æˆæœ¬) / æ—¶é—´&#10;æ•°å€¼è¶Šé«˜ï¼Œå•å±€æ—¶é—´æ”¶ç›Šæ•ˆç‡è¶Šé«˜">æ¯åˆ†é’ŸæœŸæœ›å‡€æ”¶ç›Š(Jâ‚) <span class="sort-indicator"></span></th>
                                <th onclick="sortRankings('j2')" title="æ¯å•ä½æˆæœ¬æœŸæœ›å‡€æ”¶ç›Š = ((æ”¶ç›Š-æŸè€—)Ã—æ’¤ç¦»ç‡ - æˆæœ¬) / æˆæœ¬&#10;æ•°å€¼è¶Šé«˜ï¼Œèµ„æœ¬ä½¿ç”¨æ•ˆç‡è¶Šé«˜">æ¯å•ä½æˆæœ¬æœŸæœ›å‡€æ”¶ç›Š(Jâ‚‚) <span class="sort-indicator"></span></th>
                                <th title="åŸºäºä¸‰è§’æ´²æ”¶ç›ŠæŒ‡æ•°çš„è‡ªé€‚åº”ç»¼åˆè¯„çº§&#10;æ ¹æ®å½“å‰ç­–ç•¥åˆ†å¸ƒå®æ—¶è®¡ç®—é˜ˆå€¼&#10;ç¡®ä¿æ¯ä¸ªç­‰çº§éƒ½æœ‰åˆç†çš„ç­–ç•¥åˆ†å¸ƒ&#10;Sçº§ï¼šå“è¶Š (æœ€é«˜RI*)&#10;Açº§ï¼šä¼˜ç§€ (æ¬¡é«˜RI*)&#10;Bçº§ï¼šè‰¯å¥½ (ä¸­ç­‰RI*)&#10;Cçº§ï¼šä¸€èˆ¬ (è¾ƒä½RI*)&#10;Dçº§ï¼šè¾ƒå·® (æœ€ä½RI*)">ç»¼åˆè¯„çº§</th>
                            </tr>
                        </thead>
                        <tbody id="rankingsBody">
                            <!-- Rankings will be populated by JavaScript -->
                        </tbody>
                    </table>

                    <!-- Data Editor -->
                    <div class="data-editor" id="dataEditor">
                        <h3 style="margin-bottom: 15px;">åŸºç¡€å‚æ•°ç¼–è¾‘ (å•ä½ï¼šä¸‡å“ˆå¤«å¸/åˆ†é’Ÿ)</h3>
                        <table class="data-table">
                            <thead>
                                <tr>
                                    <th>ç­–ç•¥åç§°</th>
                                    <th>æ˜¾æ€§æˆæœ¬ (C)</th>
                                    <th>æŸè€— (AL)</th>
                                    <th>æ”¶ç›Š (AR)</th>
                                    <th>æ’¤ç¦»ç‡ (SR)</th>
                                    <th>è€—æ—¶ (T)</th>
                                    <th>æ“ä½œ</th>
                                </tr>
                            </thead>
                            <tbody id="dataTableBody">
                                <!-- Data will be populated by JavaScript -->
                            </tbody>
                        </table>
                        <div style="margin-top: 15px; text-align: center;">
                            <button class="btn btn-success" onclick="addNewStrategy()">+ æ·»åŠ æ–°ç­–ç•¥</button>
                            <button class="btn btn-primary" onclick="applyDataChanges()" style="margin-left: 10px;">åº”ç”¨æ›´æ”¹</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- æ”¶ç›Šæ›²çº¿å›¾ -->
            <div class="step" id="chart-section">
                <h2 class="step-title">æ”¶ç›Šæ›²çº¿å¯¹æ¯”</h2>
                <p style="text-align: center; margin-bottom: 20px; font-size: 1.1em;">
                    å„æµæ´¾ä¸è®¡æ—¶é—´æˆæœ¬çš„ç´¯è®¡å‡€æ”¶ç›Šå¯¹æ¯”ï¼ˆè£…å¤‡æˆæœ¬ vs å®é™…æ”¶ç›Šï¼‰
                </p>

                <!-- å›¾è¡¨æ§åˆ¶é¢æ¿ -->
                <div class="chart-controls" style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0; text-align: center;">
                    <!-- æ¨ªè½´é—´éš”è®¾ç½® -->
                    <div style="margin-bottom: 15px;">
                        <label style="margin-right: 15px; font-weight: bold;">æ¨ªè½´é—´éš”è®¾ç½®ï¼š</label>
                        <button class="btn btn-secondary" onclick="adjustChartInterval(5)">5åˆ†é’Ÿ</button>
                        <button class="btn btn-primary" onclick="adjustChartInterval(10)">10åˆ†é’Ÿ</button>
                        <button class="btn btn-secondary" onclick="adjustChartInterval(15)">15åˆ†é’Ÿ</button>
                        <button class="btn btn-secondary" onclick="adjustChartInterval(20)">20åˆ†é’Ÿ</button>
                        <input type="number" id="customInterval" min="1" max="60" value="10" style="width: 60px; margin-left: 15px; padding: 5px;" placeholder="è‡ªå®šä¹‰">
                        <button class="btn btn-secondary" onclick="setCustomInterval()" style="margin-left: 5px;">è®¾ç½®</button>
                    </div>

                    <!-- ç­–ç•¥é€‰æ‹©å™¨ -->
                    <div style="margin-bottom: 15px;">
                        <label style="margin-right: 15px; font-weight: bold;">ç­–ç•¥é€‰æ‹©ï¼š</label>
                        <div id="strategySelectors" style="display: inline-block; margin-left: 10px;">
                            <!-- ç­–ç•¥é€‰æ‹©å™¨å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                        </div>
                        <button class="btn btn-secondary" onclick="selectAllStrategies()" style="margin-left: 10px;">å…¨é€‰</button>
                        <button class="btn btn-secondary" onclick="deselectAllStrategies()">å…¨ä¸é€‰</button>
                    </div>

                    <!-- çŠ¶æ€æ˜¾ç¤º -->
                    <div style="margin-top: 10px; color: #666;">
                        å½“å‰é—´éš”ï¼š<span id="currentInterval" style="font-weight: bold; color: #2196F3;">10</span>åˆ†é’Ÿï¼Œ
                        æœ€å¤§æ—¶é—´ï¼š<span id="maxTime" style="font-weight: bold; color: #4CAF50;">150</span>åˆ†é’Ÿï¼Œ
                        é‡‡æ ·ç‚¹æ•°ï¼š<span style="font-weight: bold; color: #FF9800;">15</span>ä¸ª
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="earningsChart"></canvas>
                </div>

                <div class="chart-data-table">
                    <h4 id="chartTableTitle">ğŸ“ˆ æ”¶ç›Šæ•°æ®å¯¹æ¯”</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>ç­–ç•¥</th>
                                <th>å±€æ•°</th>
                                <th>è£…å¤‡æ€»æˆæœ¬</th>
                                <th>æœŸæœ›æ€»æ”¶ç›Š</th>
                                <th>ç´¯è®¡å‡€æ”¶ç›Š</th>
                            </tr>
                        </thead>
                        <tbody id="chartTableBody">
                            <!-- æ•°æ®å°†é€šè¿‡JavaScriptç”Ÿæˆ -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Global state
        let kappa = 1.0; // æ—¶é—´æœºä¼šæˆæœ¬å‚æ•°
        let currentScenario = 'normal';
        let currentSort = { column: 'ri_star', direction: 'desc' };
        let chartInterval = 10; // æ¨ªè½´é—´éš”ï¼Œé»˜è®¤10åˆ†é’Ÿ
        const SAMPLE_POINTS = 15; // å›ºå®šé‡‡æ ·ç‚¹æ•°
        let visibleStrategies = new Set(); // è®°å½•å¯è§çš„ç­–ç•¥

        // Base game data from paper (Table in Section 2.2)
        let gameData = {
            strategies: [
                {
                    name: 'å…¨è£…çŒ›æ”»',
                    C: 250, AL: 200, AR: 400, SR: 1/3, T: 25
                },
                {
                    name: 'ç»ç’ƒå¤§ç‚®çŒ›æ”»',
                    C: 120, AL: 50, AR: 200, SR: 0.5, T: 25
                },
                {
                    name: 'å››å¥—åŠè£…çŒ›æ”»æœºå¯†',
                    C: 200, AL: 100, AR: 300, SR: 0.4, T: 25
                },
                {
                    name: 'ç»å¯†å µæ’¤ç¦»ç‚¹',
                    C: 100, AL: 30, AR: 400, SR: 0.45, T: 30
                },
                {
                    name: 'ç»å¯†é¿æˆ˜è·‘åˆ€',
                    C: 60, AL: 0, AR: 175, SR: 0.5, T: 20
                },
                {
                    name: 'ç»æµå­¦ç»å¯†è·‘åˆ€',
                    C: 50, AL: 0, AR: 70, SR: 0.2, T: 5
                },
                {
                    name: 'æœºå¯†å¤§åé€Ÿæ’¤',
                    C: 15, AL: 0, AR: 35, SR: 0.7, T: 5
                },
                {
                    name: 'æ™®é€šç»æµå­¦',
                    C: 0, AL: 0, AR: 4, SR: 1.0, T: 2.5
                },
                {
                    name: 'å…¨è£…å•ä¸‰çŒ›æ”»',
                    C: 500, AL: 400, AR: 1100, SR: 1/3, T: 25
                }
            ]
        };

        // Initialize the page
        function init() {
            updateRankings();
            updateDataTable();
        }

        // Step 1: Kappa adjustment functions
        function adjustKappa(amount) {
            kappa = Math.max(0.1, kappa + amount);
            document.getElementById('kappaValue').textContent = kappa.toFixed(1);
            document.getElementById('kappaInput').value = kappa.toFixed(1);
            updateRankings();
        }

        function setKappa(value) {
            kappa = Math.max(0.1, parseFloat(value) || 1.0);
            document.getElementById('kappaValue').textContent = kappa.toFixed(1);
            document.getElementById('kappaInput').value = kappa.toFixed(1);
            updateRankings();
        }

        // Step 2: Scenario selection
        function selectScenario(scenario) {
            currentScenario = scenario;

            // Update UI
            document.querySelectorAll('.scenario-card').forEach(card => {
                card.classList.remove('selected');
            });
            event.currentTarget.classList.add('selected');

            updateRankings();
            updateDataTable();
        }

        // Apply scenario adjustments to get working parameters
        function applyScenarioAdjustments(strategy) {
            let workingParams = { ...strategy };

            if (currentScenario === 'runner') {
                // è·‘åˆ€é¼ é¼ ï¼šè·‘åˆ€ç­–ç•¥æ”¶ç›Š+30%ï¼Œæ’¤ç¦»ç‡+0.1ï¼›çŒ›æ”»ç­–ç•¥æ’¤ç¦»ç‡-0.1
                if (strategy.name.includes('è·‘åˆ€')) {
                    workingParams.AR = strategy.AR * 1.3;
                    workingParams.SR = Math.min(1.0, strategy.SR + 0.1);
                } else if (strategy.name.includes('çŒ›æ”»') || strategy.name.includes('å µæ’¤ç¦»ç‚¹')) {
                    workingParams.SR = Math.max(0.1, strategy.SR - 0.1);
                }
            } else if (currentScenario === 'expert') {
                // æŠ€æœ¯é«˜æ‰‹ï¼šçŒ›æ”»ç­–ç•¥æ’¤ç¦»ç‡+0.1ï¼Œæ”¶ç›Š+30%ï¼Œæ—¶é•¿-20%
                if (strategy.name.includes('çŒ›æ”»') || strategy.name.includes('å µæ’¤ç¦»ç‚¹')) {
                    workingParams.AR = strategy.AR * 1.3;
                    workingParams.SR = Math.min(1.0, strategy.SR + 0.1);
                    workingParams.T = strategy.T * 0.8;
                }
            }
            // æ™®é€šç©å®¶ï¼šæ— å˜åŒ–

            return workingParams;
        }

        // Calculate Delta Earning Index metrics (following Section 3.1)
        function calculateDeltaEarningMetrics(strategy) {
            const params = applyScenarioAdjustments(strategy);

            // Step 1: Î”R = AR - AL
            const deltaR = params.AR - params.AL;

            // Step 2: Î”R_adj = Î”R Ã— SR
            const deltaR_adj = deltaR * params.SR;

            // Step 3: C_eff = C + Îº Ã— T
            const c_eff = params.C + kappa * params.T;

            // Step 4: Calculate three indicators
            // RI* = Î”R_adj / (C_eff Ã— T)
            const ri_star = c_eff > 0 && params.T > 0 ? deltaR_adj / (c_eff * params.T) : 0;

            // Jâ‚ = Î”R_adj / T (æ¯åˆ†é’ŸæœŸæœ›å‡€æ”¶ç›Š)
            const j1 = params.T > 0 ? deltaR_adj / params.T : 0;

            // Jâ‚‚ = Î”R_adj / C_eff (æ¯å•ä½æˆæœ¬æœŸæœ›å‡€æ”¶ç›Š)
            const j2 = c_eff > 0 ? deltaR_adj / c_eff : 0;

            return {
                name: strategy.name,
                ri_star: ri_star,
                j1: j1,
                j2: j2,
                deltaR_adj: deltaR_adj,
                c_eff: c_eff,
                deltaR: deltaR,
                workingParams: params,
                strategy: strategy.name // for sorting by name
            };
        }

        // Get rank based on RI* value using adaptive distribution algorithm
        function getRankByRIStar(ri_star, allRiStars = null) {
            // å¦‚æœæ²¡æœ‰æä¾›æ‰€æœ‰æ•°æ®ï¼Œä»å…¨å±€è®¡ç®—
            if (!allRiStars) {
                allRiStars = gameData.strategies.map(s => {
                    const metrics = calculateDeltaEarningMetrics(s);
                    return metrics.ri_star;
                });
            }

            // å¦‚æœç­–ç•¥æ•°é‡å¤ªå°‘ï¼Œä½¿ç”¨å›ºå®šé˜ˆå€¼ä½œä¸ºå¤‡é€‰
            if (allRiStars.length < 3) {
                if (ri_star >= 0.15) return 'S';
                if (ri_star >= 0.08) return 'A';
                if (ri_star >= 0.03) return 'B';
                if (ri_star >= 0.01) return 'C';
                return 'D';
            }

            // æ’åºRI*å€¼ï¼ˆä»é«˜åˆ°ä½ï¼‰
            const sorted = [...allRiStars].sort((a, b) => b - a);
            const n = sorted.length;

            // è‡ªé€‚åº”åˆ†é…ç®—æ³•ï¼šç¡®ä¿æ¯ä¸ªç­‰çº§éƒ½æœ‰åˆç†çš„åˆ†å¸ƒ
            let thresholds = calculateAdaptiveThresholds(sorted, n);

            // æ ¹æ®è‡ªé€‚åº”é˜ˆå€¼è¯„å®šç­‰çº§
            if (ri_star >= thresholds.S) return 'S';
            if (ri_star >= thresholds.A) return 'A';
            if (ri_star >= thresholds.B) return 'B';
            if (ri_star >= thresholds.C) return 'C';
            return 'D';
        }

        // è®¡ç®—è‡ªé€‚åº”é˜ˆå€¼
        function calculateAdaptiveThresholds(sorted, n) {
            // åŸºç¡€åˆ†é…ç­–ç•¥ï¼šæ ¹æ®ç­–ç•¥æ•°é‡åŠ¨æ€è°ƒæ•´åˆ†é…æ¯”ä¾‹
            let distribution;
            if (n <= 5) {
                // ç­–ç•¥å°‘æ—¶ï¼Œä¼˜å…ˆç¡®ä¿æ¯ä¸ªç­‰çº§éƒ½æœ‰ä»£è¡¨
                distribution = [1, 1, 1, 1, Math.max(0, n - 4)];
            } else if (n <= 10) {
                // ä¸­ç­‰æ•°é‡ï¼Œç›¸å¯¹å‡åŒ€åˆ†å¸ƒ
                distribution = [
                    Math.ceil(n * 0.15), // Sçº§çº¦15%
                    Math.ceil(n * 0.25), // Açº§çº¦25%
                    Math.ceil(n * 0.25), // Bçº§çº¦25%
                    Math.ceil(n * 0.20), // Cçº§çº¦20%
                    Math.max(1, n - Math.ceil(n * 0.85)) // Dçº§å‰©ä½™
                ];
            } else {
                // ç­–ç•¥å¤šæ—¶ï¼Œæ›´æ¥è¿‘æ­£æ€åˆ†å¸ƒ
                distribution = [
                    Math.ceil(n * 0.10), // Sçº§çº¦10%
                    Math.ceil(n * 0.20), // Açº§çº¦20%
                    Math.ceil(n * 0.30), // Bçº§çº¦30%
                    Math.ceil(n * 0.25), // Cçº§çº¦25%
                    Math.max(1, n - Math.ceil(n * 0.85)) // Dçº§å‰©ä½™
                ];
            }

            // ç¡®ä¿æ€»æ•°ä¸è¶…è¿‡å®é™…ç­–ç•¥æ•°
            const total = distribution.reduce((sum, count) => sum + count, 0);
            if (total > n) {
                // æŒ‰æ¯”ä¾‹ç¼©å‡ï¼Œä¼˜å…ˆä¿æŒé«˜çº§åˆ«çš„æ•°é‡
                let excess = total - n;
                for (let i = distribution.length - 1; i >= 0 && excess > 0; i--) {
                    const reduction = Math.min(distribution[i] - 1, excess);
                    distribution[i] -= reduction;
                    excess -= reduction;
                }
            }

            // æ ¹æ®åˆ†é…ç¡®å®šé˜ˆå€¼
            let thresholds = { S: 0, A: 0, B: 0, C: 0 };
            let currentIndex = 0;

            // Sçº§é˜ˆå€¼
            if (distribution[0] > 0) {
                thresholds.S = sorted[currentIndex];
                currentIndex += distribution[0];
            }

            // Açº§é˜ˆå€¼
            if (distribution[1] > 0 && currentIndex < n) {
                thresholds.A = sorted[currentIndex];
                currentIndex += distribution[1];
            }

            // Bçº§é˜ˆå€¼
            if (distribution[2] > 0 && currentIndex < n) {
                thresholds.B = sorted[currentIndex];
                currentIndex += distribution[2];
            }

            // Cçº§é˜ˆå€¼
            if (distribution[3] > 0 && currentIndex < n) {
                thresholds.C = sorted[currentIndex];
            }

            // ç¡®ä¿é˜ˆå€¼é€’å‡
            if (thresholds.A === thresholds.S) thresholds.A = thresholds.S * 0.8;
            if (thresholds.B === thresholds.A) thresholds.B = thresholds.A * 0.8;
            if (thresholds.C === thresholds.B) thresholds.C = thresholds.B * 0.8;

            return thresholds;
        }

        // Update rankings display
        function updateRankings() {
            const metrics = gameData.strategies.map(s => calculateDeltaEarningMetrics(s));

            // æå–æ‰€æœ‰RI*å€¼ç”¨äºè‡ªé€‚åº”è¯„çº§
            const allRiStars = metrics.map(m => m.ri_star);

            // Apply current sorting
            metrics.sort((a, b) => {
                const aValue = a[currentSort.column];
                const bValue = b[currentSort.column];

                // Handle undefined values
                const aVal = aValue !== undefined ? aValue : -Infinity;
                const bVal = bValue !== undefined ? bValue : -Infinity;

                return currentSort.direction === 'desc' ? bVal - aVal : aVal - bVal;
            });

            // Generate HTML
            let html = '';
            metrics.forEach(metric => {
                const rank = getRankByRIStar(metric.ri_star, allRiStars);

                html += `
                    <tr>
                        <td><strong>${metric.name}</strong></td>
                        <td>${(metric.ri_star || 0).toFixed(3)}</td>
                        <td>${(metric.j1 || 0).toFixed(3)}</td>
                        <td>${(metric.j2 || 0).toFixed(3)}</td>
                        <td class="rank-${rank.toLowerCase()}">${rank}</td>
                    </tr>
                `;
            });

            document.getElementById('rankingsBody').innerHTML = html;
        }

        
        // Update data table
        function updateDataTable() {
            let html = '';
            gameData.strategies.forEach((strategy, index) => {
                const params = applyScenarioAdjustments(strategy);
                html += `
                    <tr>
                        <td><input type="text" value="${strategy.name}" data-index="${index}" data-field="name" style="width: 120px;"></td>
                        <td><input type="number" value="${params.C}" data-index="${index}" data-field="C"></td>
                        <td><input type="number" value="${params.AL}" data-index="${index}" data-field="AL"></td>
                        <td><input type="number" value="${params.AR}" data-index="${index}" data-field="AR"></td>
                        <td><input type="number" value="${params.SR}" step="0.01" min="0" max="1" data-index="${index}" data-field="SR"></td>
                        <td><input type="number" value="${params.T}" step="0.5" data-index="${index}" data-field="T"></td>
                        <td><button class="btn btn-danger" onclick="deleteStrategy(${index})" ${gameData.strategies.length <= 1 ? 'disabled' : ''}>åˆ é™¤</button></td>
                    </tr>
                `;
            });
            document.getElementById('dataTableBody').innerHTML = html;
        }

        // Toggle data editor
        function toggleDataEditor() {
            const editor = document.getElementById('dataEditor');
            editor.classList.toggle('active');
        }

        // Apply data changes
        function applyDataChanges() {
            const inputs = document.querySelectorAll('#dataTableBody input');
            inputs.forEach(input => {
                const index = parseInt(input.dataset.index);
                const field = input.dataset.field;
                let value;

                if (field === 'name') {
                    value = input.value.trim();
                    if (!value) {
                        alert('ç­–ç•¥åç§°ä¸èƒ½ä¸ºç©ºï¼');
                        return;
                    }
                } else {
                    value = parseFloat(input.value);
                    if (isNaN(value)) {
                        alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ•°å­—ï¼');
                        return;
                    }
                }

                gameData.strategies[index][field] = value;
            });

            // æ›´æ–°ç­–ç•¥é€‰æ‹©å™¨
            initStrategySelectors();

            // æ›´æ–°æ‰€æœ‰ç›¸å…³ç»„ä»¶
            updateRankings();
            updateChart();
            toggleDataEditor();
        }

        // Sort rankings
        function sortRankings(column) {
            if (currentSort.column === column) {
                currentSort.direction = currentSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                currentSort.column = column;
                currentSort.direction = 'desc';
            }

            // Update sort indicators
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });

            // Find the clicked header and its indicator
            const headers = document.querySelectorAll('#rankingsTable th');
            headers.forEach(header => {
                const onclickAttr = header.getAttribute('onclick');
                if (onclickAttr && onclickAttr.includes(`'${column}'`)) {
                    const indicator = header.querySelector('.sort-indicator');
                    if (indicator) {
                        indicator.textContent = currentSort.direction === 'desc' ? 'â†“' : 'â†‘';
                    }
                }
            });

            updateRankings();
        }

        // æ›´æ–°æ˜¾ç¤ºä¿¡æ¯
        function updateChartDisplay() {
            const maxTime = SAMPLE_POINTS * chartInterval;
            document.getElementById('currentInterval').textContent = chartInterval;
            document.getElementById('maxTime').textContent = maxTime;
        }

        // è°ƒæ•´å›¾è¡¨é—´éš”å‡½æ•°
        function adjustChartInterval(interval) {
            chartInterval = interval;
            document.getElementById('customInterval').value = interval;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const buttons = document.querySelectorAll('.chart-controls button');
            buttons.forEach(btn => {
                if (btn.textContent.includes(interval + 'åˆ†é’Ÿ') && btn.textContent !== 'è®¾ç½®') {
                    btn.className = 'btn btn-primary';
                } else if (btn.textContent !== 'è®¾ç½®') {
                    btn.className = 'btn btn-secondary';
                }
            });

            updateChartDisplay();

            // é‡æ–°åˆ›å»ºå›¾è¡¨
            createEarningsChart();
        }

        // è‡ªå®šä¹‰é—´éš”å‡½æ•°
        function setCustomInterval() {
            const customValue = parseInt(document.getElementById('customInterval').value);
            if (customValue && customValue >= 1 && customValue <= 60) {
                adjustChartInterval(customValue);

                // é‡ç½®æ‰€æœ‰æŒ‰é’®çŠ¶æ€
                const buttons = document.querySelectorAll('.chart-controls button');
                buttons.forEach(btn => {
                    if (btn.textContent !== 'è®¾ç½®') {
                        btn.className = 'btn btn-secondary';
                    }
                });
            } else {
                alert('è¯·è¾“å…¥1-60ä¹‹é—´çš„æ•°å­—');
                document.getElementById('customInterval').value = chartInterval;
            }
        }

        // åˆå§‹åŒ–ç­–ç•¥é€‰æ‹©å™¨
        function initStrategySelectors() {
            const container = document.getElementById('strategySelectors');
            container.innerHTML = '';

            // é»˜è®¤æ˜¾ç¤ºæ‰€æœ‰ç­–ç•¥
            visibleStrategies.clear();
            gameData.strategies.forEach(strategy => {
                visibleStrategies.add(strategy.name);
            });

            // åˆ›å»ºé€‰æ‹©å™¨
            gameData.strategies.forEach((strategy, index) => {
                const label = document.createElement('label');
                label.style.cssText = 'margin-right: 15px; cursor: pointer; display: inline-flex; align-items: center;';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.style.cssText = 'margin-right: 5px;';
                checkbox.onchange = function() {
                    toggleStrategy(strategy.name, this.checked);
                };

                const colorBox = document.createElement('span');
                colorBox.style.cssText = `display: inline-block; width: 12px; height: 12px; background: ${getStrategyColor(strategy.name)}; margin-right: 5px; border-radius: 2px;`;

                const text = document.createTextNode(strategy.name);

                label.appendChild(checkbox);
                label.appendChild(colorBox);
                label.appendChild(text);
                container.appendChild(label);
            });
        }

        // è·å–ç­–ç•¥é¢œè‰²
        function getStrategyColor(strategyName) {
            const predefinedColors = [
                { name: 'å…¨è£…çŒ›æ”»', color: '#9C27B0' },
                { name: 'ç»ç’ƒå¤§ç‚®çŒ›æ”»', color: '#F44336' },
                { name: 'ç»å¯†å µæ’¤ç¦»ç‚¹', color: '#795548' },
                { name: 'ç»å¯†é¿æˆ˜è·‘åˆ€', color: '#FF9800' },
                { name: 'æœºå¯†å¤§åé€Ÿæ’¤', color: '#2196F3' },
                { name: 'æ™®é€šç»æµå­¦', color: '#4CAF50' }
            ];

            // æŸ¥æ‰¾é¢„å®šä¹‰é¢œè‰²
            const strategy = predefinedColors.find(s => s.name === strategyName);
            if (strategy) {
                return strategy.color;
            }

            // ä¸ºæ–°ç­–ç•¥ç”Ÿæˆé¢œè‰²
            const additionalColors = ['#E91E63', '#9C27B0', '#673AB7', '#3F51B5', '#009688', '#00BCD4', '#FF5722', '#795548', '#607D8B', '#FFC107'];
            const index = gameData.strategies.findIndex(s => s.name === strategyName);
            return additionalColors[index % additionalColors.length];
        }

        // åˆ‡æ¢ç­–ç•¥å¯è§æ€§
        function toggleStrategy(strategyName, visible) {
            if (visible) {
                visibleStrategies.add(strategyName);
            } else {
                visibleStrategies.delete(strategyName);
            }
            createEarningsChart(); // é‡æ–°åˆ›å»ºå›¾è¡¨
        }

        // å…¨é€‰ç­–ç•¥
        function selectAllStrategies() {
            const checkboxes = document.querySelectorAll('#strategySelectors input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
            gameData.strategies.forEach(strategy => {
                visibleStrategies.add(strategy.name);
            });
            createEarningsChart();
        }

        // å…¨ä¸é€‰ç­–ç•¥
        function deselectAllStrategies() {
            const checkboxes = document.querySelectorAll('#strategySelectors input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
            visibleStrategies.clear();
            createEarningsChart();
        }

        // æ»šåŠ¨åˆ°å›¾è¡¨éƒ¨åˆ†
        function scrollToChart(event) {
            event.preventDefault();
            const chartSection = document.getElementById('chart-section');
            chartSection.scrollIntoView({
                behavior: 'smooth',
                block: 'start'
            });
        }

        // åˆ é™¤ç­–ç•¥
        function deleteStrategy(index) {
            if (gameData.strategies.length <= 1) {
                alert('è‡³å°‘éœ€è¦ä¿ç•™ä¸€ä¸ªç­–ç•¥ï¼');
                return;
            }

            if (confirm(`ç¡®å®šè¦åˆ é™¤ç­–ç•¥"${gameData.strategies[index].name}"å—ï¼Ÿ`)) {
                gameData.strategies.splice(index, 1);
                updateDataTable();
                initStrategySelectors();
                updateRankings();
                updateChart();
            }
        }

        // æ·»åŠ æ–°ç­–ç•¥
        function addNewStrategy() {
            const newStrategy = {
                name: `æ–°ç­–ç•¥${gameData.strategies.length + 1}`,
                C: 100,
                AL: 50,
                AR: 200,
                SR: 0.5,
                T: 15
            };

            gameData.strategies.push(newStrategy);
            updateDataTable();
            initStrategySelectors();
            updateRankings();
            updateChart();

            // æ»šåŠ¨åˆ°æ–°æ·»åŠ çš„ç­–ç•¥è¡Œ
            setTimeout(() => {
                const rows = document.querySelectorAll('#dataTableBody tr');
                if (rows.length > 0) {
                    rows[rows.length - 1].scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                }
            }, 100);
        }

        // å›¾è¡¨ç›¸å…³åŠŸèƒ½
        function createEarningsChart() {
            // åŠ¨æ€åˆ›å»ºæ‰€æœ‰ç­–ç•¥çš„å›¾è¡¨æ•°æ®ï¼Œä½†åªæ˜¾ç¤ºè¢«é€‰ä¸­çš„ç­–ç•¥
            const allChartStrategies = gameData.strategies.map(strategy => ({
                ...strategy,
                color: getStrategyColor(strategy.name)
            }));

            // åªä¿ç•™è¢«é€‰ä¸­çš„ç­–ç•¥
            const chartStrategies = allChartStrategies.filter(strategy => visibleStrategies.has(strategy.name));

            // åº”ç”¨æƒ…æ™¯è°ƒæ•´
            function applyScenarioToStrategy(strategy) {
                let workingParams = { ...strategy };

                if (currentScenario === 'runner') {
                    if (strategy.name.includes('è·‘åˆ€')) {
                        workingParams.AR = strategy.AR * 1.3;
                        workingParams.SR = Math.min(1.0, strategy.SR + 0.1);
                    } else if (strategy.name.includes('çŒ›æ”»') || strategy.name.includes('å µæ’¤ç¦»ç‚¹')) {
                        workingParams.SR = Math.max(0.1, strategy.SR - 0.1);
                    }
                } else if (currentScenario === 'expert') {
                    if (strategy.name.includes('çŒ›æ”»') || strategy.name.includes('å µæ’¤ç¦»ç‚¹')) {
                        workingParams.AR = strategy.AR * 1.3;
                        workingParams.SR = Math.min(1.0, strategy.SR + 0.1);
                        workingParams.T = strategy.T * 0.8;
                    }
                }

                return workingParams;
            }

            // è®¡ç®—å•å±€å‡€æ”¶ç›Šï¼ˆä¸è®¡æ—¶é—´æˆæœ¬ï¼‰
            function calculateNetProfit(strategy) {
                const params = applyScenarioToStrategy(strategy);
                const deltaR = params.AR - params.AL;
                const expectedRevenue = deltaR * params.SR;
                return expectedRevenue - params.C;
            }

            // ç”Ÿæˆå›¾è¡¨æ•°æ®ï¼ˆå›ºå®š15ä¸ªé‡‡æ ·ç‚¹ï¼‰
            function generateChartData() {
                const datasets = [];
                const timePoints = [];
                const allGameCounts = []; // å­˜å‚¨æ‰€æœ‰ç­–ç•¥çš„æ¸¸æˆå±€æ•°

                // è®¡ç®—æœ€å¤§æ—¶é—´ = é‡‡æ ·ç‚¹æ•° Ã— é—´éš”
                const maxTime = SAMPLE_POINTS * chartInterval;

                // ç”Ÿæˆå›ºå®šæ•°é‡çš„æ•°æ®ç‚¹
                for (let i = 0; i < SAMPLE_POINTS; i++) {
                    const minutes = i * chartInterval;
                    timePoints.push(minutes);
                }

                
                chartStrategies.forEach((strategy, index) => {
                    const netProfit = calculateNetProfit(strategy);
                    const data = [];
                    const gameCount = [];

                    timePoints.forEach(minutes => {
                        const games = Math.floor(minutes / applyScenarioToStrategy(strategy).T);
                        const totalProfit = games * netProfit;
                        data.push(totalProfit);
                        gameCount.push(games);
                    });

                    allGameCounts.push(gameCount); // ä¿å­˜æ¯ä¸ªç­–ç•¥çš„æ¸¸æˆå±€æ•°

                    datasets.push({
                        label: strategy.name,
                        data: data,
                        borderColor: strategy.color,
                        backgroundColor: strategy.color + '20',
                        borderWidth: 3,
                        fill: false,
                        tension: 0.1,
                        pointRadius: 4,
                        pointHoverRadius: 7
                    });
                });

                return { timePoints, datasets, gameCount: allGameCounts };
            }

            // åˆ›å»ºå›¾è¡¨
            const ctx = document.getElementById('earningsChart').getContext('2d');

            // é”€æ¯ç°æœ‰å›¾è¡¨
            if (window.earningsChart && typeof window.earningsChart.destroy === 'function') {
                window.earningsChart.destroy();
            }

            const { timePoints, datasets, gameCount } = generateChartData();

            
            window.earningsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timePoints,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'å„æµæ´¾ç´¯è®¡å‡€æ”¶ç›Šæ›²çº¿ï¼ˆä¸è®¡æ—¶é—´æˆæœ¬ï¼‰',
                            font: {
                                size: 16,
                                weight: 'bold'
                            },
                            padding: 20
                        },
                        legend: {
                            display: true,
                            position: 'bottom',
                            labels: {
                                padding: 20,
                                font: {
                                    size: 12
                                }
                            }
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                title: function(context) {
                                    return `æ¸¸æˆæ—¶é—´ï¼š${context[0].label} åˆ†é’Ÿ`;
                                },
                                label: function(context) {
                                    const strategyIndex = context.datasetIndex;
                                    const games = gameCount[strategyIndex][context.dataIndex];
                                    const profit = context.parsed.y;
                                    return [
                                        `${context.dataset.label}`,
                                        `å±€æ•°ï¼š${games} å±€`,
                                        `ç´¯è®¡å‡€æ”¶ç›Šï¼š${profit.toFixed(1)} ä¸‡`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'æ¸¸æˆæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                source: 'data',
                                autoSkip: false,
                                callback: function(value, index, values) {
                                    // ä½¿ç”¨ç´¢å¼•è®¡ç®—æ—¶é—´å€¼
                                    const timeValue = index * chartInterval;
                                    return timeValue + ' åˆ†';
                                }
                            },
                            grid: {
                                display: true,
                                color: '#e0e0e0'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'ç´¯è®¡å‡€æ”¶ç›Šï¼ˆä¸‡ï¼‰',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + ' ä¸‡';
                                }
                            },
                            grid: {
                                color: function(context) {
                                    if (context.tick.value === 0) {
                                        return '#e74c3c';
                                    }
                                    return '#e0e0e0';
                                },
                                lineWidth: function(context) {
                                    if (context.tick.value === 0) {
                                        return 2;
                                    }
                                    return 1;
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        // ç”Ÿæˆ60åˆ†é’Ÿæ•°æ®è¡¨æ ¼
        function generateChartTable() {
            // ä½¿ç”¨æ‰€æœ‰ç­–ç•¥æ•°æ®
            const chartStrategies = gameData.strategies;

            const tableBody = document.getElementById('chartTableBody');
            tableBody.innerHTML = '';

            chartStrategies.forEach(strategy => {
                const row = tableBody.insertRow();

                // åº”ç”¨æƒ…æ™¯è°ƒæ•´
                let params = { ...strategy };
                if (currentScenario === 'runner') {
                    if (strategy.name.includes('è·‘åˆ€')) {
                        params.AR = strategy.AR * 1.3;
                        params.SR = Math.min(1.0, strategy.SR + 0.1);
                    } else if (strategy.name.includes('çŒ›æ”»') || strategy.name.includes('å µæ’¤ç¦»ç‚¹')) {
                        params.SR = Math.max(0.1, strategy.SR - 0.1);
                    }
                } else if (currentScenario === 'expert') {
                    if (strategy.name.includes('çŒ›æ”»') || strategy.name.includes('å µæ’¤ç¦»ç‚¹')) {
                        params.AR = strategy.AR * 1.3;
                        params.SR = Math.min(1.0, strategy.SR + 0.1);
                        params.T = strategy.T * 0.8;
                    }
                }

                const maxTime = SAMPLE_POINTS * chartInterval;
                const games = Math.floor(maxTime / params.T);
                const totalCost = strategy.C * games;
                const deltaR = params.AR - params.AL;
                const expectedRevenue = deltaR * params.SR;
                const totalRevenue = expectedRevenue * games;
                const netProfit = totalRevenue - totalCost;

                row.insertCell(0).textContent = strategy.name;
                row.insertCell(1).textContent = games;
                row.insertCell(2).textContent = totalCost.toFixed(0);
                row.insertCell(3).textContent = totalRevenue.toFixed(0);

                const profitCell = row.insertCell(4);
                profitCell.textContent = netProfit.toFixed(0);

                if (netProfit > 0) {
                    profitCell.className = 'positive';
                } else if (netProfit < 0) {
                    profitCell.className = 'negative';
                } else {
                    profitCell.className = 'zero';
                }
            });
        }

        // æ›´æ–°å›¾è¡¨
        function updateChart() {
            if (window.earningsChart && typeof window.earningsChart.destroy === 'function') {
                window.earningsChart.destroy();
            }

            // æ›´æ–°è¡¨æ ¼æ ‡é¢˜
            const maxTime = SAMPLE_POINTS * chartInterval;
            document.getElementById('chartTableTitle').textContent = `ğŸ“ˆ ${maxTime}åˆ†é’Ÿæ”¶ç›Šæ•°æ®å¯¹æ¯”`;

            createEarningsChart();
            generateChartTable();
        }

        // åˆå§‹åŒ–æ—¶åˆ›å»ºå›¾è¡¨
        function init() {
            updateRankings();
            updateDataTable();

            // åˆå§‹åŒ–ç­–ç•¥é€‰æ‹©å™¨
            initStrategySelectors();

            // è®¾ç½®é»˜è®¤æŒ‰é’®çŠ¶æ€å’Œæ˜¾ç¤ºä¿¡æ¯
            updateChartDisplay();
            document.getElementById('customInterval').value = chartInterval;
            const buttons = document.querySelectorAll('.chart-controls button');
            buttons.forEach(btn => {
                if (btn.textContent.includes(chartInterval + 'åˆ†é’Ÿ') && btn.textContent !== 'è®¾ç½®') {
                    btn.className = 'btn btn-primary';
                } else if (btn.textContent !== 'è®¾ç½®') {
                    btn.className = 'btn btn-secondary';
                }
            });

            updateChart();
        }

        // ä¿®æ”¹æƒ…æ™¯é€‰æ‹©å‡½æ•°ï¼Œæ·»åŠ å›¾è¡¨æ›´æ–°
        const originalSelectScenario = selectScenario;
        selectScenario = function(scenario) {
            originalSelectScenario(scenario);
            updateChart(); // æ›´æ–°å›¾è¡¨
        };

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>